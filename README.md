# cs-300-porfolio-submission


- What was the problem you were solving in the projects for this course?

I aimed to create a course planning program that reads course information from a file, stores it in a binary search tree, and allows users to search for courses and their prerequisites.

- How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by defining a Course struct and a BinarySearchTree class. I parsed course data from the file, implemented insertion and search operations, and created a user menu for interaction. Understanding data structures was crucial to efficiently organize and manage course data, enabling quick searches and ordered traversal.

- How did you overcome any roadblocks you encountered while going through the activities or project?

I encountered challenges in parsing and organizing course data and in handling user input validation. I overcame these by carefully implementing the parseCourse function and by adding input validation in the menu loop. Referring to documentation and breaking down tasks into smaller steps helped me find solutions.

- How has your work on this project expanded your approach to designing software and developing programs?

Working on this project expanded my approach by emphasizing the importance of encapsulation, modularization, and object-oriented design. It showed me how to leverage data structures for efficient data organization and retrieval. I gained insights into handling real-world data sources and creating user-friendly interfaces.

- How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

This project evolved my programming approach by highlighting the significance of clear variable naming, code organization, and separation of concerns. It taught me to write maintainable code by encapsulating functionality in classes, making code readable through meaningful comments, and adapting designs to accommodate future changes. I learned to balance performance considerations with code readability and maintainability.
